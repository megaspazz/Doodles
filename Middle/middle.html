<html>
	<head>
		<title>Middle</title>
	</head>
	<body>
		<svg id="svgGame"></svg>
		<div>
			<input id="txtInput" type="text" onkeydown="processInput();" autofocus></input>
		</div>
		<div id="divWords"></div>
		
		<script src="words.js"></script>
		<script type="text/javascript">
			const WIDTH = 800;
			const HEIGHT = 600;
			const RADIUS = 160;
			const FONT_SIZE = 24;
			const FONT_FAMILY = "Helvetica, sans-serif";
			const LETTER_RADIUS = 32;
			const MIDDLE_BORDER_SIZE = 8;
			
			function createSVGElement(tag, attrs, text) {
				let elt = document.createElementNS(SVG_NS, tag);
				for (const [name, value] of Object.entries(attrs)) {
					elt.setAttribute(name, value);
				}
				if (text) {
					elt.textContent = text;
				}
				return elt;
			}
			
			function style(styles) {
				return Object.entries(styles).map(([name, value]) => {
					return name + ": " + value + ";";
				}).join(" ");
			}
			
			function drawCircle(word, x0, y0, radius, startRads, deltaRads) {
				let svgGame = document.getElementById("svgGame");
				let outerCircle = createSVGElement("circle", {
					"cx": x0,
					"cy": y0,
					"r": radius,
					"style": style({
						"fill": "SteelBlue",
					}),
				});
				svgGame.prepend(outerCircle);
				for (let i = 0; i < word.length; ++i) {
					let x = x0 + radius * Math.cos(startRads + i * deltaRads);
					let y = y0 + radius * Math.sin(startRads + i * deltaRads);
					log(word, x0, y0, radius, startRads, deltaRads);
					let letterCircle = createSVGElement("circle", {
						"cx": x,
						"cy": y,
						"r": LETTER_RADIUS,
						"style": style({
							"fill": "SkyBlue",
						}),
					});
					let letterText = createSVGElement("text", {
						"x": x,
						"y": y,
						"font-size": FONT_SIZE,
						"font-family": FONT_FAMILY,
						"text-anchor": "middle",
						"dominant-baseline": "middle",
					}, word[i]);
					log(letterText);
					svgGame.appendChild(letterCircle);
					svgGame.appendChild(letterText);
				}
			}
			
			function init(prefix, middle, suffix) {
				for (let i = 0; i < prefix.length(); ++i) {
					
				}
			}
			
			const SVG_NS = "http://www.w3.org/2000/svg";
			
			/*
			class Render {
				constructor(divWords) {
					this.divWords = divWords;
					this.lengthToDiv = [];
				}
				
				initFromGame(game) {
				game.solutions.forEach((words, len) => {
					let div = document.createElement("div");
					let header = document.createElement("h2");
					let ol = document.createElement("ol");
					let wordsRemaining = 0;
					words.forEach((state, word) => {
						switch (state) {
							case Game.NOT_FOUND: {
								++wordsRemaining;
								break;
							}
							case Game.FOUND: {
								let li = document.createElement("li");
								li.innerHTML = word;
								ol.append(li);
								break;
							}
						}
					});
					this.lengthToDiv[len] = div;
					header.innerHTML = index + "-letter words (" + g + " remaining)";
					div.appendChild(header);
					div.appendChild(ol);
					divWords.appendChild(div);
				});
				};
			}
			*/
			
			function renderWords() {
				let divWords = document.getElementById("divWords");
				divWords.innerHTML = "";
				game.solutions.forEach((words, len) => {
					let div = document.createElement("div");
					let header = document.createElement("h2");
					let ol = document.createElement("ol");
					let wordsRemaining = 0;
					words.forEach((state, word) => {
						let li = document.createElement("li");
						switch (state) {
							case Game.NOT_FOUND: {
								li.innerHTML = "?".repeat(len);
								++wordsRemaining;
								break;
							}
							case Game.FOUND: {
								li.innerHTML = word;
								break;
							}
						}
						ol.appendChild(li);
					});
					header.innerHTML = len + "-letter words (" + wordsRemaining + " remaining)";
					div.appendChild(header);
					div.appendChild(ol);
					divWords.appendChild(div);
				});
			}
			
			window.onload = function() {
				let svgGame = document.getElementById("svgGame");
				svgGame.setAttribute("width", WIDTH);
				svgGame.setAttribute("height", HEIGHT);
				
				drawCircle(game.prefix, WIDTH / 2 - RADIUS, HEIGHT / 2, RADIUS, 2 * Math.PI / (game.prefix.length + 1), 2 * Math.PI / (game.prefix.length + 1));
				drawCircle(game.suffix, WIDTH / 2 + RADIUS, HEIGHT / 2, RADIUS, Math.PI + 2 * Math.PI / (game.suffix.length + 1), 2 * Math.PI / (game.suffix.length + 1));
				let middleLetterCircle = createSVGElement("circle", {
					"cx": WIDTH / 2,
					"cy": HEIGHT / 2,
					"r": LETTER_RADIUS + MIDDLE_BORDER_SIZE / 2,
					"style": style({
						"fill": "DeepSkyBlue",
						"stroke": "DodgerBlue",
						"stroke-width": MIDDLE_BORDER_SIZE,
					}),
				});
				let middleLetterText = createSVGElement("text", {
					"x": WIDTH / 2,
					"y": HEIGHT / 2,
					"font-size": FONT_SIZE,
					"font-family": FONT_FAMILY,
					"text-anchor": "middle",
					"dominant-baseline": "middle",
				}, game.middle);
				svgGame.appendChild(middleLetterCircle);
				svgGame.appendChild(middleLetterText);
				
				renderWords();
				
				let txtInput = document.getElementById("txtInput");
				txtInput.onkeydown = processInput;
			}
			
			function processInput(e) {
				if (e.key == "Enter") {
					let txtInput = document.getElementById("txtInput");
					let word = txtInput.value.toUpperCase();
					if (game.solutions[word.length]?.get(word) == Game.NOT_FOUND) {
						log("winner: " + word);
						game.solutions[word.length].set(word, Game.FOUND);
						renderWords();
					} else {
						log("loser: " + word);
					}
					txtInput.value = "";
				}
			}
			
			class Game {
				static NOT_EXIST = 0;
				static NOT_FOUND = 1;
				static FOUND = 2;
				
				constructor(prefix, middle, suffix) {
					this.prefix = prefix;
					this.middle = middle;
					this.suffix = suffix;
					
					this.prefixFreq = Game.#makeFreq(prefix);
					this.suffixFreq = Game.#makeFreq(suffix);
					
					this.solutions = [];
					WORDS_LIST.forEach(w => {
						if (this.validate(w)) {
							let words = this.solutions[w.length];
							if (!words) {
								words = new Map();
								this.solutions[w.length] = words;
							}
							//console.log(w, this.validate(w));
							words.set(w, Game.NOT_FOUND);
						}
					});
				}
				
				validate(word) {
					for (let i = 1; i + 1 < word.length; ++i) {
						//console.log(word, i, word[i], word[i] == this.middle, Game.#validatePart(this.prefixFreq, word.substring(0, i)), Game.#validatePart(this.suffixFreq, word.substring(i + 1)))
						if (word[i] == this.middle && Game.#validatePart(this.prefixFreq, word.substring(0, i)) && Game.#validatePart(this.suffixFreq, word.substring(i + 1))) {
							return true;
						}
					}
					return false;
				}
				
				static generate(prefixSize, suffixSize) {
					let prefix = Game.#randomLetters(prefixSize).join("");
					let middle = Game.#randomLetter();
					let suffix = Game.#randomLetters(suffixSize).join("");
					return new Game(prefix, middle, suffix);
				}
				
				static #wordsList = WORDS_LIST;
				static #wordsDict = WORDS_DICT;
				
				static #makeFreq(word) {
					let freq = {};
					[...word].forEach(c => {
						freq[c] = ~~freq[c] + 1;
					});
					return freq;
				}
				
				static #validatePart(freq, part) {
					let partFreq = Game.#makeFreq(part);
					for (let [c, count] of Object.entries(partFreq)) {
						if (count > ~~freq[c]) {
							return false;
						}
					}
					return true;
				}
				
				static #randomLetter() {
					let i = ~~(Math.random() * Game.#wordsList.length);
					let word = Game.#wordsList[i];
					let j = ~~(Math.random() * word.length);
					return word[j];
				}
				
				static #randomLetters(num) {
					let arr = [];
					for (let i = 0; i < num; ++i) {
						arr[i] = Game.#randomLetter();
					}
					return arr;
				}
			}
			
			//let game = new Game("HELL", "O", "RLDW");
			let game = Game.generate(5, 5);
			
			const DEBUG = false;
			
			function log() {
				if (DEBUG) {
					console.log(...arguments);
				}
			}
		</script>
	</body>
</html>
